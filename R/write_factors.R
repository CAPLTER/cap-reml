#' @title write_factors
#'
#' @description write_factors creates a template as a csv file for supplying
#'   code definition metadata for factors in a tabular data object that resides
#'   in the R environment.
#'
#' @details The csv template generated by write_factors includes the field names
#'   of all fields defined as factors, and each level of the factor. The
#'   template supports the ability to provide a definition for each level. The
#'   csv file is written with the name of the data object in R + "_factors". The
#'   create_dataTable function will search for this file when creating a EML
#'   dataTable entity.
#'
#' @note Input is the name of a data frame (after all factors have been
#'   declared). In a previous version of this function, the factor names and
#'   levels must have been defined (e.g., a_q2 <- c(`1` = "male", `2` =
#'   "female")) in advance. As of 2017-12-15, the function has been modified
#'   such that factor names and levels can be identified in the code (sensu
#'   above) or not identified. If left unidentified, the definition for each
#'   factor level is written as metadata_not_provided and can be modified in the
#'   csv file that is written to disk. If factor names and levels are identified
#'   (sensu above), this function draws on the names of factors in the dataframe
#'   (not from the manually defined factor names and levels), so care must be
#'   taken such that those names (i.e., variables in the data frame that are
#'   factors and the name of the defined factor) match precisely. Because output
#'   is to a file that will be read by the create_dataTable function, a mix of
#'   factor names and levels defined in code (e.g., if you have a lot of
#'   repeating factors throughout the data set) and adding the metadata to the
#'   file is perfectly acceptable.
#'
#' @note manual approach that we are encapsulating with the function:
#' meter_factors <- rbind(
#'   data.frame(
#'     attributeName = "reach",
#'     code = names(reach),
#'     definition = unname(reach)
#'   ),
#'   data.frame(
#'     attributeName = "urbanized",
#'     code = names(urbanized),
#'     definition = unname(urbanized)
#'   )
#' )
#'
#' @param dfname The unquoted name of the R data frame or Tibble.
#'
#' @import dplyr
#'
#' @return The name of the file generated is returned, and a template for
#'   providing code definition metadata as a csv file with the file name of the
#'   R data object + "_factors.csv" is created in the working directory.
#'
#' @examples
#' \dontrun{
#'
#'  write_factors(R data object)
#'
#' }
#'
#' @export

write_factors <- function(dfname) {

  listOfFactors <- sapply(dfname, is.factor)
  trueList <- which(listOfFactors)

  dfname_factors <- data.frame()
  for(i in 1:length(trueList)) {

    if(exists(names(trueList)[i])) {
      factor_elements <- get(names(trueList)[i])
      temp_frame <- rbind(
        data.frame(
          attributeName = names(trueList)[i],
          code = names(factor_elements),
          definition = unname(factor_elements)
        ))
      dfname_factors <- rbind(dfname_factors, temp_frame)
    } else {
      temp_frame <- rbind(
        data.frame(
          attributeName = names(trueList)[i],
          code = levels(dfname[[(trueList)[i]]]),
          # code = levels(dfname[,names(trueList)[i]]),
          definition = 'metadata_not_provided'
        ))
      dfname_factors <- rbind(dfname_factors, temp_frame)
    }
  } # close loop

  # write dfname of factor data to file
  objectName <- paste0(deparse(substitute(dfname)), "_factors")

  # need to add a prompt to overwrite an existing file (future!)
  # if(file.exists(paste0(objectName, ".csv"))) {
  #   over_write <- readline(prompt="file exists, over write (y/n)?")
  #   if(over_write)
  # }

  write_csv(dfname_factors, path = paste0(objectName, ".csv"))

  return(objectName)

} # close function
