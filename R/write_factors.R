#' @title write_factors
#'
#' @description write_factors creates a template as a csv file for supplying
#'   code definition metadata for factors in a tabular data object that resides
#'   in the R environment.
#'
#' @details The csv template generated by write_factors includes the field names
#'   of all fields defined as factors, and each level of the factor. The
#'   template supports the ability to provide a definition for each level. The
#'   csv file is written with the name of the data object in R + "_factors". The
#'   create_dataTable function will search for this file when creating a EML
#'   dataTable entity.
#'
#' @note Input is the name of a data frame (after all factors have been
#'   declared). In a previous version of this function, the factor names and
#'   levels must have been defined (e.g., a_q2 <- c(`1` = "male", `2` =
#'   "female")) in advance. As of 2017-12-15, the function has been modified
#'   such that factor names and levels can be identified in the code (sensu
#'   above) or not identified. If left unidentified, the definition for each
#'   factor level is written as metadata_not_provided and can be modified in the
#'   csv file that is written to disk. If factor names and levels are identified
#'   (sensu above), this function draws on the names of factors in the dataframe
#'   (not from the manually defined factor names and levels), so care must be
#'   taken such that those names (i.e., variables in the data frame that are
#'   factors and the name of the defined factor) match precisely. Because output
#'   is to a file that will be read by the create_dataTable function, a mix of
#'   factor names and levels defined in code (e.g., if you have a lot of
#'   repeating factors throughout the data set) and adding the metadata to the
#'   file is perfectly acceptable.
#'
#' @note manual approach that we are encapsulating with the function:
#'   meter_factors <- rbind( data.frame( attributeName = "reach", code =
#'   names(reach), definition = unname(reach) ), data.frame( attributeName =
#'   "urbanized", code = names(urbanized), definition = unname(urbanized) ) )
#'
#' @param dfname The unquoted name of the R data frame or Tibble.
#' @param overwrite Logical indicating if an existing factors file in the target
#'   directory should be overwritten.
#'
#' @import dplyr
#'
#' @return The name of the file generated is returned, and a template for
#'   providing code definition metadata as a csv file with the file name of the
#'   R data object + "_factors.csv" is created in the working directory.
#'
#' @examples
#' \dontrun{
#'
#'  write_factors(R data object)
#'  write_factors(R data object, overwrite = 'yes')
#'
#' }
#'
#' @export

write_factors <- function(dfname, overwrite = FALSE) {

  # establish object name for checking if exists and, ultimately, writing to file
  objectName <- paste0(deparse(substitute(dfname)), "_factors")
  fileName <- paste0(objectName, ".csv")

  # check if attributes already exist for given data entity
  if(file.exists(fileName) && overwrite == FALSE) {
    stop(paste0("file ", fileName, " already exists, use write_factors(overwrite = TRUE) to overwrite"))
  }

  # list of factors in target data entity
  listOfFactors <- dfname %>%
    select_if(is.factor) %>%
    names()

  # build a tibble of factors for a given field
  factorToFrame <- function(dfname, field) {

    factorsInFrame <- tibble(
      attributeName = field,
      code = levels(dfname[[field]]),
      definition = 'metadata_not_provided'
    )

    return(factorsInFrame)

  } # close factorToFrame

  dfnameFactors <- map_df(.x = listOfFactors, .f = factorToFrame, dfname = dfname)

  # write dfname of factor data to file
  write_csv(dfnameFactors,
            path = fileName)

  return(objectName)

} # close function
